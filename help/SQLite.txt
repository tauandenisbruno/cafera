INSERT ================================================================================================================================================

Para fazer um insert na tabela `usuario` com os campos `nome` e `senha` no SQLite, você pode usar a seguinte sintaxe SQL:

*Exemplo*
```
INSERT INTO usuario (nome, senha) VALUES ('nome_do_usuario', 'senha_do_usuario');
```

*Usando Java*
- Se você estiver usando Java para interagir com o banco de dados SQLite, você pode usar a classe `PreparedStatement` para executar a query de insert.

```
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class Exemplo {
    public static void main(String[] args) {
        String url = "jdbc:sqlite:nome_do_banco.db";
        String nome = "nome_do_usuario";
        String senha = "senha_do_usuario";

        try (Connection conn = DriverManager.getConnection(url)) {
            String sql = "INSERT INTO usuario (nome, senha) VALUES (?, ?)";
            PreparedStatement pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, nome);
            pstmt.setString(2, senha);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            System.out.println(e.getMessage());
        }
    }
}
```

*Conclusão*
- Lembre-se de sempre usar parâmetros preparados (`?`) para evitar ataques de injeção de SQL.
- Certifique-se de que a tabela `usuario` exista no banco de dados e que os campos `nome` e `senha` estejam definidos corretamente.



UPDATE ===================================================================================================================================================

Para fazer um update no campo nome e senha da tabela usuario no SQLite, você pode usar a seguinte sintaxe SQL:

Exemplo

UPDATE usuario SET nome = 'novo_nome', senha = 'nova_senha' WHERE id = id_do_usuario;


Usando Java
- Se você estiver usando Java para interagir com o banco de dados SQLite, você pode usar a classe PreparedStatement para executar a query de update.


import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;

public class Exemplo {
    public static void main(String[] args) {
        String url = "jdbc:sqlite:nome_do_banco.db";
        int id = id_do_usuario;
        String nome = "novo_nome";
        String senha = "nova_senha";

        try (Connection conn = DriverManager.getConnection(url)) {
            String sql = "UPDATE usuario SET nome = ?, senha = ? WHERE id = ?";
            PreparedStatement pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, nome);
            pstmt.setString(2, senha);
            pstmt.setInt(3, id);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            System.out.println(e.getMessage());
        }
    }
}


Conclusão
- Lembre-se de sempre usar parâmetros preparados (?) para evitar ataques de injeção de SQL.
- Certifique-se de que a tabela usuario exista no banco de dados e que os campos nome e senha estejam definidos corretamente.
- O WHERE é usado para especificar qual linha deve ser atualizada. Se você não especificar um WHERE, todas as linhas da tabela serão atualizadas.

SELECT ===================================================================================================================================================

Para fazer um select nos campos `nome` e `senha` da tabela `usuario` no SQLite, você pode usar a seguinte sintaxe SQL:

*Exemplo*
```
SELECT nome, senha FROM usuario;
```

*Selecionar com condição*
- Se você quiser selecionar apenas os registros que atendem a uma condição específica, você pode usar o `WHERE`.

```
SELECT nome, senha FROM usuario WHERE id = id_do_usuario;
```

*Usando Java*
- Se você estiver usando Java para interagir com o banco de dados SQLite, você pode usar a classe `PreparedStatement` para executar a query de select.

```
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Exemplo {
    public static void main(String[] args) {
        String url = "jdbc:sqlite:nome_do_banco.db";
        int id = id_do_usuario;

        try (Connection conn = DriverManager.getConnection(url)) {
            String sql = "SELECT nome, senha FROM usuario WHERE id = ?";
            PreparedStatement pstmt = conn.prepareStatement(sql);
            pstmt.setInt(1, id);
            ResultSet rs = pstmt.executeQuery();

            while (rs.next()) {
                String nome = rs.getString("nome");
                String senha = rs.getString("senha");
                System.out.println("Nome: " + nome + ", Senha: " + senha);
            }
        } catch (SQLException e) {
            System.out.println(e.getMessage());
        }
    }
}
```

*Conclusão*
- Lembre-se de sempre usar parâmetros preparados (`?`) para evitar ataques de injeção de SQL.
- Certifique-se de que a tabela `usuario` exista no banco de dados e que os campos `nome` e `senha` estejam definidos corretamente.
- O `ResultSet` é usado para armazenar os resultados da query de select. Você pode iterar sobre ele para acessar os dados.

PASTA PROJETOS================================================================================================================================================

Sim, você pode usar um caminho relativo para o banco de dados SQLite. Aqui estão algumas opções:

*Opção 1: Usar o diretório atual*
- Você pode usar o diretório atual do projeto como referência.

```
String sql_local = "jdbc:sqlite:./nome_do_banco.db";
```

*Opção 2: Usar o diretório do projeto*
- Você pode usar o diretório do projeto como referência.

```
String sql_local = "jdbc:sqlite:" + System.getProperty("user.dir") + "/nome_do_banco.db";
```

*Opção 3: Usar um recurso do projeto*
- Se o banco de dados estiver dentro do pacote de recursos do projeto, você pode usar o `ClassLoader` para obter o caminho.

```
String sql_local = "jdbc:sqlite:" + getClass().getClassLoader().getResource("nome_do_banco.db").getPath();
```

*Conclusão*
- Lembre-se de que o caminho relativo pode variar dependendo da configuração do projeto e do ambiente de execução.
- Certifique-se de que o banco de dados esteja no local correto e que o caminho esteja correto.
